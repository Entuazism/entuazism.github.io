<h1>Графы для самых маленьких: DFS</h1>

<p>В этой статье хотелось бы рассказать об одном из самых распространенных алгоритмов на графах — об обходе в глубину — на примере решения задачи о нахождении пути сквозь лабиринт. Всем, кому это интересно — добро пожаловать под кат!</p>

<p>//////////////////////////</p>

<h2 id="">Постановка задачи</h2>

<p>Работать над «сырым» лабиринтом достаточно неудобно (по крайней мере, введение графа будет ненаглядным), поэтому мы разобьем его на «комнаты», соединенные между собой перегородками. Примерно так, как показано на рисунке справа.</p>

<p>//////////////////////////</p>

<p>Теперь задача приняла такой вид: есть множество комнат, между некоторыми из них можно перемещаться. Требуется найти путь из комнаты A в комнату B. В теории графов «комнаты» называются вершинами, «переходы» между ними — ребрами. Комната А — начальная вершина, комната В — конечная. Граф на картинке справа можно перерисовать в несколько более распространенном в теории графов виде:</p>

<p>///////////////////////////</p>

<p>Здесь овалы — это вершины (или комнаты), линии — ребра (или переходы между ними). Вершина 1 — начальная, вершина 12 — конечная.</p>

<h2>И как же мы будем решать эту задачу?</h2>

<p>Первое, что хочется сделать — написать перебор: в каждый момент времени находимся в какой-то вершине, и идем из нее во всех соседей:</p>

<h3>Перебор</h3>

<p>Предполагается, что граф хранится в массиве vector<vector<int>> edges, причем edges[v] содержит номера всех вершин, к которым есть ребро от v. Также предполагается, что в глобальной переменной finish хранится номер конечной вершины.</vector<int></p>

<pre><code>void travel(int v)
{

}
</code></pre>

<p>Увы, этот код не работает уже на графе из трех вершин, в котором ребрами соединена каждая вершина с каждой — при запуске от вершины 1 мы заходим в вершину 2, из нее — в вершину 1, из нее — опять в вершину 2,… и в какой-то момент программа просто падает из-за переполнения стека.</p>

<h2>Что же делать?</h2>

<p>Решение, которое сразу приходит на ум — помечать каждую вершину при входе в нее, и никогда не ходить в уже помеченные вершины — это и есть обход в глубину:</p>

<h3>DFS</h3>

<pre><code>void DFS(int v)
{
    if (mark[v] != 0)  // Если мы здесь уже были, то тут больше делать нечего
    {
        return;
    }
    mark[v] = 1;   // Помечаем, что мы здесь были
    if (v == finish)   // Проверяем, конец ли
    {
        cout &lt;&lt; "Hooray! The path was found!\n";
        return;
    }
    for (int i = 0; i &lt; (int)edges[v].size(); ++i)  // Для каждого ребра
    {
        DFS(edges[v][i]);  // Запускаемся из соседа
    }
}
</code></pre>

<h2>И что с того?</h2>

<p>Да, программа прошла по какому-то пути, но как определить, по какому? Будем для каждой вершины запоминать, откуда мы в нее пришли, в специальном массиве prior.</p>

<h3>DFS</h3>

<pre><code>void DFS(int v, int from)
{
    if (mark[v] != 0)  // Если мы здесь уже были, то тут больше делать нечего
    {
        return;
    }
    mark[v] = 1;   // Помечаем, что мы здесь были
    prior[v] = from;  // Запоминаем, откуда пришли
    if (v == finish)   // Проверяем, конец ли
    {
        cout &lt;&lt; "Hooray! The path was found!\n";
        return;
    }
    for (int i = 0; i &lt; (int)edges[v].size(); ++i)  // Для каждого ребра
    {
        DFS(edges[v][i], v);  // Запускаемся из соседа
    }
}
</code></pre>

<p>Тогда задача восстановления пути будет тривиальной:</p>

<pre><code>get_path
vector&lt;int&gt; get_path()
{
    vector&lt;int&gt; ans;
    for (int v = finish; v != start; v = prior[v])  // Проходим по пути из конца в начало
    {
        ans.push_back(v);  // Запоминаем вершину
    }
    ans.push_back(start);
    reverse(ans.begin(), ans.end());  // Переворачиваем путь
    return ans;
}
</code></pre>

<h2>А почему это работает?</h2>

<p>Алгоритм всегда найдет путь до вершины, если он существует. Доказательство: Для произвольного графа G: База. Пути из не более, чем 1 вершины алгоритм находит верно (путь от начальной вершины до нее же). Предположение: Алгоритм посещает все вершины, находящиеся на расстоянии не более, чем k — 1, от начальной. Шаг: Рассмотрим любую вершину v, находящуюся на расстоянии k от начальной. Она, очевидно, соединена ребром с какой-то вершиной, находящейся на расстоянии k — 1 от начальной — назовем ее w. Значит, мы перейдем в вершину v при просмотре вершины w.</p>

<h2>Сколько ресурсов требуется алгоритму?</h2>

<p>Алгоритм просматривает каждое ребро один раз, и выполняет для каждой вершины константное число действий. Обозначая число вершин как V, а ребер — как E, получаем, что время работы — O(V+E). Глубина рекурсии, в которой мы находимся, не превышает общего числа вызовов функции DFS — числа вершин. То есть, объем памяти, необходимый для работы алгоритма, равен O(V).</p>

<h2>Нерекурсивный DFS</h2>

<p>Любой рекурсивный алгоритм можно переписать в нерекурсивном виде. Вот код для DFS:</p>

<h3>DFS</h3>

<pre><code>void DFS()
{
    stack&lt;int&gt; s;
    s.push(start);
    while (!s.empty())
    {
        int v = s.top();
        s.pop();
        for (int i = 0; i &lt; edges[v].size(); ++i)
        {
            if (mark[edges[v][i]] == 0)
            {
                s.push(edges[v][i]);
                mark[edges[v][i]] = 1;
            }
        }
    }
}
</code></pre>

<h2>А что дальше?</h2>

<p>Надеюсь, было познавательно. В следующих статьях я постараюсь рассказать побольше о том, какие задачи можно решать с помощью DFS, а также зачем нужны BFS, Dijkstra и другие алгоритмы на графах.</p>
