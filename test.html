<h1>Графы для самых маленьких: DFS</h1>
<ul>
<li><a title="Вы не подписаны на этот хаб" href="https://habr.com/ru/hub/algorithms/">Алгоритмы</a></li>
</ul>
<div>
<div id="post-content-body" data-io-article-url="https://habr.com/ru/post/200074/">В этой статье хотелось бы рассказать об одном из самых распространенных алгоритмов на графах &mdash; об обходе в глубину &mdash; на примере решения задачи о нахождении пути сквозь лабиринт. Всем, кому это интересно &mdash; добро пожаловать под кат!<br /><img src="https://habrastorage.org/getpro/habr/post_images/7fa/964/81d/7fa96481dab0e4d868bb82f77adb4f1f.jpg" /><br /><a name="habracut"></a><br />
<h4>Постановка задачи</h4>
<br /><img src="https://habrastorage.org/getpro/habr/post_images/2e7/466/b05/2e7466b05ca84f21eb216732a2a98117.gif" align="right" />Работать над &laquo;сырым&raquo; лабиринтом достаточно неудобно (по крайней мере, введение графа будет ненаглядным), поэтому мы разобьем его на &laquo;комнаты&raquo;, соединенные между собой перегородками. Примерно так, как показано на рисунке справа.<br /><br />Теперь задача приняла такой вид: есть множество комнат, между некоторыми из них можно перемещаться. Требуется найти путь из комнаты A в комнату B.<br />В теории графов &laquo;комнаты&raquo; называются вершинами, &laquo;переходы&raquo; между ними &mdash; ребрами. Комната А &mdash; начальная вершина, комната В &mdash; конечная.<br />Граф на картинке справа можно перерисовать в несколько более распространенном в теории графов виде:<br /><img src="https://habrastorage.org/getpro/habr/post_images/4a5/f7a/73f/4a5f7a73fc544d64a9cc4fa00111a001.png" /><br />Здесь овалы &mdash; это вершины (или комнаты), линии &mdash; ребра (или переходы между ними). Вершина 1 &mdash; начальная, вершина 12 &mdash; конечная.<br />
<h4>И как же мы будем решать эту задачу?</h4>
<br />Первое, что хочется сделать &mdash; написать перебор: в каждый момент времени находимся в какой-то вершине, и идем из нее во всех соседей:<br />
<div class="spoiler spoiler_open"><strong class="spoiler_title">Перебор</strong>
<div class="spoiler_text">Предполагается, что граф хранится в массиве vector&lt;vector&lt;int&gt;&gt; edges, причем edges[v] содержит номера всех вершин, к которым есть ребро от v. Также предполагается, что в глобальной переменной finish хранится номер конечной вершины.<br />
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">travel</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span>
</span>{
    <span class="hljs-keyword">if</span> (v == finish)   <span class="hljs-comment">// Проверяем, конец ли</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hooray! The path was found!\n"</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)edges[v].size(); ++i)  <span class="hljs-comment">// Для каждого ребра</span>
    {
        travel(edges[v][i]);  <span class="hljs-comment">// Запускаемся из соседа</span>
    }
}
</code></pre>
</div>
</div>
<br />Увы, этот код не работает уже на графе из трех вершин, в котором ребрами соединена каждая вершина с каждой &mdash; при запуске от вершины 1 мы заходим в вершину 2, из нее &mdash; в вершину 1, из нее &mdash; опять в вершину 2,&hellip; и в какой-то момент программа просто падает из-за переполнения стека.<br />
<h4>Что же делать?</h4>
<br />Решение, которое сразу приходит на ум &mdash; помечать каждую вершину при входе в нее, и никогда не ходить в уже помеченные вершины &mdash; это и есть обход в глубину:<br />
<div class="spoiler spoiler_open"><strong class="spoiler_title">DFS</strong>
<div class="spoiler_text">
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span>
</span>{
    <span class="hljs-keyword">if</span> (mark[v] != <span class="hljs-number">0</span>)  <span class="hljs-comment">// Если мы здесь уже были, то тут больше делать нечего</span>
    {
        <span class="hljs-keyword">return</span>;
    }
    mark[v] = <span class="hljs-number">1</span>;   <span class="hljs-comment">// Помечаем, что мы здесь были</span>
    <span class="hljs-keyword">if</span> (v == finish)   <span class="hljs-comment">// Проверяем, конец ли</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hooray! The path was found!\n"</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)edges[v].size(); ++i)  <span class="hljs-comment">// Для каждого ребра</span>
    {
        DFS(edges[v][i]);  <span class="hljs-comment">// Запускаемся из соседа</span>
    }
}
</code></pre>
</div>
</div>
<br />
<h4>И что с того?</h4>
<br />Да, программа прошла по какому-то пути, но как определить, по какому?<br />Будем для каждой вершины запоминать, откуда мы в нее пришли, в специальном массиве prior.<br />
<div class="spoiler spoiler_open"><strong class="spoiler_title">DFS</strong>
<div class="spoiler_text">
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> from)</span>
</span>{
    <span class="hljs-keyword">if</span> (mark[v] != <span class="hljs-number">0</span>)  <span class="hljs-comment">// Если мы здесь уже были, то тут больше делать нечего</span>
    {
        <span class="hljs-keyword">return</span>;
    }
    mark[v] = <span class="hljs-number">1</span>;   <span class="hljs-comment">// Помечаем, что мы здесь были</span>
    prior[v] = from;  <span class="hljs-comment">// Запоминаем, откуда пришли</span>
    <span class="hljs-keyword">if</span> (v == finish)   <span class="hljs-comment">// Проверяем, конец ли</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hooray! The path was found!\n"</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)edges[v].size(); ++i)  <span class="hljs-comment">// Для каждого ребра</span>
    {
        DFS(edges[v][i], v);  <span class="hljs-comment">// Запускаемся из соседа</span>
    }
}
</code></pre>
</div>
</div>
<br />Тогда задача восстановления пути будет тривиальной:<br />
<div class="spoiler spoiler_open"><strong class="spoiler_title">get_path</strong>
<div class="spoiler_text">
<pre><code class="cpp hljs"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; get_path()
{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = finish; v != start; v = prior[v])  <span class="hljs-comment">// Проходим по пути из конца в начало</span>
    {
        ans.push_back(v);  <span class="hljs-comment">// Запоминаем вершину</span>
    }
    ans.push_back(start);
    reverse(ans.begin(), ans.end());  <span class="hljs-comment">// Переворачиваем путь</span>
    <span class="hljs-keyword">return</span> ans;
}
</code></pre>
</div>
</div>
<br />
<h4>А почему это работает?</h4>
<br />Алгоритм всегда найдет путь до вершины, если он существует. Доказательство:<br />Для произвольного графа G:<br />База. Пути из не более, чем 1 вершины алгоритм находит верно (путь от начальной вершины до нее же).<br />Предположение: Алгоритм посещает все вершины, находящиеся на расстоянии не более, чем k &mdash; 1, от начальной.<br />Шаг: Рассмотрим любую вершину v, находящуюся на расстоянии k от начальной. Она, очевидно, соединена ребром с какой-то вершиной, находящейся на расстоянии k &mdash; 1 от начальной &mdash; назовем ее w. Значит, мы перейдем в вершину v при просмотре вершины w.<br />
<h4>Сколько ресурсов требуется алгоритму?</h4>
<br />Алгоритм просматривает каждое ребро один раз, и выполняет для каждой вершины константное число действий. Обозначая число вершин как V, а ребер &mdash; как E, получаем, что время работы &mdash; O(V+E).<br />Глубина рекурсии, в которой мы находимся, не превышает общего числа вызовов функции DFS &mdash; числа вершин. То есть, объем памяти, необходимый для работы алгоритма, равен O(V).<br />
<h4>Нерекурсивный DFS</h4>
<br />Любой рекурсивный алгоритм можно переписать в нерекурсивном виде. Вот код для DFS:<br />
<div class="spoiler spoiler_open"><strong class="spoiler_title">DFS</strong>
<div class="spoiler_text">
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;
    s.push(start);
    <span class="hljs-keyword">while</span> (!s.empty())
    {
        <span class="hljs-keyword">int</span> v = s.top();
        s.pop();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges[v].size(); ++i)
        {
            <span class="hljs-keyword">if</span> (mark[edges[v][i]] == <span class="hljs-number">0</span>)
            {
                s.push(edges[v][i]);
                mark[edges[v][i]] = <span class="hljs-number">1</span>;
            }
        }
    }
}
</code></pre>
</div>
</div>
<br />
<h4>А что дальше?</h4>
<br />Надеюсь, было познавательно. В следующих статьях я постараюсь рассказать побольше о том, какие задачи можно решать с помощью DFS, а также зачем нужны BFS, Dijkstra и другие алгоритмы на графах.</div>
</div>
